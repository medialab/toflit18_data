filter(product_reexportations == "Réexportation")
### On conserve uniquement les données dans la meilleure unité
Data <- Data %>%
filter(best_unit_metric == T
& export_import == Exports_imports) %>%
select(-c("best_unit_metric", "best_guess_region_prodxpart", "product_simplification",
"product_threesectors", "product_threesectorsM", "partner_grouping", "product_reexportations"))
Exports_imports = "Exports"
### Filtrage initial de la base de données
Data <- bdd_courante %>%
select(c("year", "customs_region", "export_import", "partner_orthographic",
"product_simplification", "quantity_unit_metric", "quantities_metric",
"unit_price_metric", "value", "best_guess_region_prodxpart", "product_threesectors",
"product_threesectorsM", "partner_grouping", "product_reexportations")) %>%
mutate(Date = as.Date(as.character(year), format = "%Y")) %>%
### On selectionne uniquement les produits rangés par régions
filter(best_guess_region_prodxpart == 1, year >= 1718) %>%
### On crée une nouvelle variable produit issue du produit + ville
mutate(product_simplification_ville = paste(product_simplification, "/", customs_region)) %>%
### Les chaînes de charatères sont transformés en type facteur
mutate_if(is.character, as.factor) %>%
### Si aucun prix n'est affiché, on le complète par valeur /quantité
mutate(unit_price_metric = coalesce(unit_price_metric, value / quantities_metric)) %>%
### Création ID product_simplification et ID transaction
mutate(id_prod_simp = as.numeric(product_simplification_ville),
id_trans = row_number()) %>%
### On enlève les transactions sans prix et les transactions avec un prix nul
mutate(unit_price_metric = na_if(unit_price_metric, 0),
quantities_metric = na_if(quantities_metric, 0)) %>%
drop_na() %>%
### On crée une dummy variable best_unit_metric qui pour chaque transaction vaut 1
### si la transacton est dans l'unité métrique la plus utilisée pour le produit
group_by(product_simplification_ville) %>%
mutate(best_unit_metric = names(which.max(table(quantity_unit_metric)))) %>%
ungroup() %>%
as.data.frame() %>%
mutate(best_unit_metric = best_unit_metric == quantity_unit_metric )
### Chargement de la base de données de la valeur de l'argent
Ag_value <- read.csv2("./scripts/Edouard/Silver_price/Silver_equivalent_of_the_lt_and_franc_(Hoffman).csv")
### On fusionne les deux bases de données
Data <- merge(Data, Ag_value, "year" = "year", all.x = T)
### On corrige les valeurs des prix
Data <- Data %>%
mutate(unit_price_metric = unit_price_metric * Value_of_livre,
value = value * Value_of_livre) %>%
select(-c("Value_of_livre"))
Data <- Data %>%
filter(product_threesectors == "Agriculture" | product_threesectors == "Non-agricultural primary goods") %>%
filter(product_reexportations == "Réexportation")
### On conserve uniquement les données dans la meilleure unité
Data <- Data %>%
filter(best_unit_metric == T
& export_import == Exports_imports) %>%
select(-c("best_unit_metric", "best_guess_region_prodxpart", "product_simplification",
"product_threesectors", "product_threesectorsM", "partner_grouping", "product_reexportations"))
### Filtrage initial de la base de données
Data <- bdd_courante %>%
select(c("year", "customs_region", "export_import", "partner_orthographic",
"product_simplification", "quantity_unit_metric", "quantities_metric",
"unit_price_metric", "value", "best_guess_region_prodxpart", "product_threesectors",
"product_threesectorsM", "partner_grouping", "product_reexportations")) %>%
mutate(Date = as.Date(as.character(year), format = "%Y")) %>%
### On selectionne uniquement les produits rangés par régions
filter(best_guess_region_prodxpart == 1, year >= 1718) %>%
### On crée une nouvelle variable produit issue du produit + ville
mutate(product_simplification_ville = paste(product_simplification, "/", customs_region)) %>%
### Les chaînes de charatères sont transformés en type facteur
mutate_if(is.character, as.factor) %>%
### Si aucun prix n'est affiché, on le complète par valeur /quantité
mutate(unit_price_metric = coalesce(unit_price_metric, value / quantities_metric)) %>%
### Création ID product_simplification et ID transaction
mutate(id_prod_simp = as.numeric(product_simplification_ville),
id_trans = row_number()) %>%
### On enlève les transactions sans prix et les transactions avec un prix nul
mutate(unit_price_metric = na_if(unit_price_metric, 0),
quantities_metric = na_if(quantities_metric, 0)) %>%
drop_na() %>%
### On crée une dummy variable best_unit_metric qui pour chaque transaction vaut 1
### si la transacton est dans l'unité métrique la plus utilisée pour le produit
group_by(product_simplification_ville) %>%
mutate(best_unit_metric = names(which.max(table(quantity_unit_metric)))) %>%
ungroup() %>%
as.data.frame() %>%
mutate(best_unit_metric = best_unit_metric == quantity_unit_metric )
### Chargement de la base de données de la valeur de l'argent
Ag_value <- read.csv2("./scripts/Edouard/Silver_price/Silver_equivalent_of_the_lt_and_franc_(Hoffman).csv")
### On fusionne les deux bases de données
Data <- merge(Data, Ag_value, "year" = "year", all.x = T)
### On corrige les valeurs des prix
Data <- Data %>%
mutate(unit_price_metric = unit_price_metric * Value_of_livre,
value = value * Value_of_livre) %>%
select(-c("Value_of_livre"))
Data <- Data %>%
filter(product_threesectors == "Agriculture" | product_threesectors == "Non-agricultural primary goods") %>%
filter(product_reexportations != "Réexportation")
### On conserve uniquement les données dans la meilleure unité
Data <- Data %>%
filter(best_unit_metric == T
& export_import == Exports_imports) %>%
select(-c("best_unit_metric", "best_guess_region_prodxpart", "product_simplification",
"product_threesectors", "product_threesectorsM", "partner_grouping", "product_reexportations"))
### si Remove_double == T, on rassemble les produits vendus plus de deux fois la même année
Data <- Remove_double_val(Data)
### On retire les outliers
Data <- Detect_outliers(Data, 10)
library(dplyr)
library(tidyverse)
library(stringr)
library(readr)
library(pracma)
library(hpiR)
library(modern)
rm(list = ls())
### A définir
setwd("C:/Users/pignede/Documents/GitHub/toflit18_data")
library(dplyr)
library(tidyverse)
library(stringr)
library(readr)
library(pracma)
library(openxlsx)
library(hpiR)
### A définir: emplacement du working directory
setwd("C:/Users/pignede/Documents/GitHub/toflit18_data")
### Nettoyage de l'espace de travail
rm(list = ls())
source("./scripts/Edouard/Indice_global_scripts/Indice_global_filtre_ville.R")
### Lecture de la base de donnée courante. Conservation Exports ou Imports d'une ville
Read_bdd_courante <- function(Exports_imports, Correction_indice_Ag, Product_sector, Partner) {
### On importe la base de données courante
bdd_courante <- read.csv(unz("./base/bdd courante.csv.zip", "bdd courante.csv") , encoding = "UTF-8")
### Filtrage initial de la base de données
Data <- bdd_courante %>%
select(c("year", "customs_region", "export_import", "partner_orthographic",
"product_simplification", "quantity_unit_metric", "quantities_metric",
"unit_price_metric", "value", "best_guess_region_prodxpart", "product_threesectors",
"product_threesectorsM", "partner_grouping", "product_reexportations")) %>%
mutate(Date = as.Date(as.character(year), format = "%Y")) %>%
### On selectionne uniquement les produits rangés par régions
filter(best_guess_region_prodxpart == 1, year >= 1718) %>%
### On crée une nouvelle variable produit issue du produit + ville
mutate(product_simplification_ville = paste(product_simplification, "/", customs_region)) %>%
### Les chaînes de charatères sont transformés en type facteur
mutate_if(is.character, as.factor) %>%
### Si aucun prix n'est affiché, on le complète par valeur /quantité
mutate(unit_price_metric = coalesce(unit_price_metric, value / quantities_metric)) %>%
### Création ID product_simplification et ID transaction
mutate(id_prod_simp = as.numeric(product_simplification_ville),
id_trans = row_number()) %>%
### On enlève les transactions sans prix et les transactions avec un prix nul
mutate(unit_price_metric = na_if(unit_price_metric, 0),
quantities_metric = na_if(quantities_metric, 0)) %>%
drop_na() %>%
### On crée une dummy variable best_unit_metric qui pour chaque transaction vaut 1
### si la transacton est dans l'unité métrique la plus utilisée pour le produit
group_by(product_simplification_ville) %>%
mutate(best_unit_metric = names(which.max(table(quantity_unit_metric)))) %>%
ungroup() %>%
as.data.frame() %>%
mutate(best_unit_metric = best_unit_metric == quantity_unit_metric )
### Correction indice Ag
if (Correction_indice_Ag) {
### Chargement de la base de données de la valeur de l'argent
Ag_value <- read.csv2("./scripts/Edouard/Silver_price/Silver_equivalent_of_the_lt_and_franc_(Hoffman).csv")
### On fusionne les deux bases de données
bdd_courante <- merge(bdd_courante, Ag_value, "year" = "year", all.x = T)
### On corrige les valeurs des prix
bdd_courante <- bdd_courante %>%
mutate(value = value * Value_of_livre) %>%
select(-c("Value_of_livre"))
}
### Calcule de la valeur totale du flux et du commerce initiale
Value_com_tot <- bdd_courante %>%
filter(best_guess_region_prodxpart == 1, year >= 1718) %>%
filter(export_import == Exports_imports) %>%
group_by(year) %>%
summarize(Value_tot = sum(value, na.rm = T),
Flux_tot = n()) %>%
as.data.frame()
### Calcule la valeur totale du commerce au niveau national
Value_com_tot_nat <- bdd_courante %>%
filter(best_guess_national_partner == 1, year >= 1718) %>%
filter(export_import == Exports_imports) %>%
group_by(year) %>%
summarize(Value_tot_national = sum(value, na.rm = T)) %>%
as.data.frame()
Value_com_tot <- merge(Value_com_tot, Value_com_tot_nat, "year" = "year", all.x = T)
### Correction indice Ag
if (Correction_indice_Ag) {
### Chargement de la base de données de la valeur de l'argent
Ag_value <- read.csv2("./scripts/Edouard/Silver_price/Silver_equivalent_of_the_lt_and_franc_(Hoffman).csv")
### On fusionne les deux bases de données
Data <- merge(Data, Ag_value, "year" = "year", all.x = T)
### On corrige les valeurs des prix
Data <- Data %>%
mutate(unit_price_metric = unit_price_metric * Value_of_livre,
value = value * Value_of_livre) %>%
select(-c("Value_of_livre"))
}
if(Product_sector != "All") {
if (Product_sector == "Primary goods") {
Data <- Data %>%
filter(product_threesectors == "Agriculture" | product_threesectors == "Non-agricultural primary goods")
} else if (Product_sector == "Primary coloniaux") {
Data <- Data %>%
filter(product_threesectors == "Agriculture" | product_threesectors == "Non-agricultural primary goods") %>%
filter(product_reexportations == "Réexportation")
} else if (Product_sector == "Primary european") {
Data <- Data %>%
filter(product_threesectors == "Agriculture" | product_threesectors == "Non-agricultural primary goods") %>%
filter(product_reexportations != "Réexportation")
} else if (Product_sector == "Manufactures") {
Data <- Data %>%
filter(product_threesectors == "Manufactures")
}
}
if (Partner == "Europe_et_Mediterranee") {
Data <- Data %>%
filter(partner_grouping %in% c("Allemagne", "Angleterre", "Espagne",
"Flandre et autres états de l'Empereur",
"Hollande", "France", "Italie", "Levant et Barbarie",
"Nord", "Portugal", "Suisse"))
}
if (Partner == "Reste_du_monde") {
Data <- Data %>%
filter(partner_grouping %in% c("Afrique", "Amériques", "Asie", "Etats-Unis d'Amérique",
"Monde", "Outre-mers"))
}
### On conserve uniquement les données dans la meilleure unité
Data <- Data %>%
filter(best_unit_metric == T
& export_import == Exports_imports) %>%
select(-c("best_unit_metric", "best_guess_region_prodxpart", "product_simplification",
"product_threesectors", "product_threesectorsM", "partner_grouping", "product_reexportations"))
return(list(Data, Value_com_tot))
}
Sector_index_global_calcul <- function()
{
### Création des lignes du csv
Index_pond <-  data.frame("Exports_imports" = factor(),
"Product_sector" = factor(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
### Ecriture des lignes du csv
write.csv2(Index_pond,
"./scripts/Edouard/Composition_index_results_global.csv",
row.names = F)
### Ajout au csv de la baseline et de la baseline + changement d'un paramètre pour chaque paramètre
### à l'aide de la fonction Add_new_parma défini ci-dessous
Add_new_sector_global()
Add_new_sector_global("Manufactures")
Add_new_sector_global("Non-agricultural primary goods")
Add_new_sector_global("Agriculture")
Add_new_sector_global("Primary goods")
Add_new_sector_global("Primary coloniaux")
Add_new_sector_global("Primary european")
}
Add_new_sector_global <- function(Product_sector = "All")
{
### Création des titres des lignes
Index_pond <-  data.frame("Exports_imports" = factor(),
"Product_sector" = factor(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
for (Type in c("Imports", "Exports")) {
### Calcul de l'index pour les paramètres choisis
Index <- Filter_calcul_index(Exports_imports = Type, ### On conserve les Importations ou les Exportations
Product_sector = Product_sector)
### A jout de l'index et des parts de flux et de valeur dans le commerce total, ainsi que la valeur des paramètres
### au dataframe
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Exports_imports = Type,
Product_sector = Product_sector,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i],
Part_flux = Index$Part_flux[i])
}
}
### On charge les valeurs actuelles du csv
Index_res <- read.csv2("./scripts/Edouard/Composition_index_results_global.csv", row.names = NULL)
### On ajoute le nouveau dataframe
Index_res <- rbind(Index_res, Index_pond)
### On retire les lignes si elles sont déja présentes dans le csv
### Par défaut, le nouveau résultat met à jour le précédent
Index_res <- Index_res[!duplicated(Index_res[ , 1:6], fromLast = T), ]
### On écrit le résulat dans le csv
write.csv2(Index_res,
"./scripts/Edouard/Composition_index_results_global.csv",
row.names = F)
}
Add_new_sector_global("Primary coloniaux")
Add_new_sector_global("Primary european")
Sector_index_global_calcul()
### On charge les fonctions des scripts Filtrage.R et Ventes_repetees_ponderees.R
source("./scripts/Edouard/Indice_ville_scripts/Ventes_repetees_ponderees.R")
### Nettoyage de l'espace de travail
rm(list = ls())
### On charge les fonctions des scripts Filtrage.R et Ventes_repetees_ponderees.R
source("./scripts/Edouard/Indice_ville_scripts/Ventes_repetees_ponderees.R")
Sector_index_calcul <- function()
{
### Création des lignes du csv
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Product_sector" = factor(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
### Ecriture des lignes du csv
write.csv2(Index_pond,
"./scripts/Edouard/Composition_index_results.csv",
row.names = F)
### Ajout au csv de la baseline et de la baseline + changement d'un paramètre pour chaque paramètre
### à l'aide de la fonction Add_new_parma défini ci-dessous
Add_new_sector()
Add_new_sector("Manufactures")
Add_new_sector("Non-agricultural primary goods")
Add_new_sector("Agriculture")
Add_new_sector("Primary goods")
Add_new_sector("Primary coloniaux")
Add_new_sector("Primary european")
}
Add_new_sector <- function(Product_sector = "All")
{
### Création des titres des lignes
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Product_sector" = factor(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle", "Bayonne", "Rennes")) {
for (Type in c("Imports", "Exports")) {
### Calcul de l'index pour les paramètres choisis
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Product_sector = Product_sector)
### A jout de l'index et des parts de flux et de valeur dans le commerce total, ainsi que la valeur des paramètres
### au dataframe
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Product_sector = Product_sector,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i],
Part_flux = Index$Part_flux[i])
}
}
}
### On charge les valeurs actuelles du csv
Index_res <- read.csv2("./scripts/Edouard/Composition_index_results.csv", row.names = NULL)
### On ajoute le nouveau dataframe
Index_res <- rbind(Index_res, Index_pond)
### On retire les lignes si elles sont déja présentes dans le csv
### Par défaut, le nouveau résultat met à jour le précédent
Index_res <- Index_res[!duplicated(Index_res[ , 1:7], fromLast = T), ]
### On écrit le résulat dans le csv
write.csv2(Index_res,
"./scripts/Edouard/Composition_index_results.csv",
row.names = F)
}
Sector_index_calcul()
### Lecture de la base de donnée courante. Conservation Exports ou Imports d'une ville
### Correction de l'indice par la valeur de l'argent
## Tri par secteur et par partenaire possible
Read_bdd_courante <- function(Ville, Exports_imports, Correction_indice_Ag, Product_sector, Partner) {
### On importe la base de données courante
bdd_courante <- read.csv(unz("./base/bdd courante.csv.zip", "bdd courante.csv") , encoding = "UTF-8")
### Filtrage initiale de la base de données
Data <- bdd_courante %>%
select(c("year", "customs_region", "export_import", "partner_orthographic",
"product_simplification", "quantity_unit_metric", "quantities_metric",
"unit_price_metric", "value", "best_guess_region_prodxpart",
"product_threesectors", "product_threesectorsM", "partner_grouping", "product_reexportations")) %>%
mutate(Date = as.Date(as.character(year), format = "%Y")) %>%
### On selectionne uniquement les produits rangés par régions
filter(best_guess_region_prodxpart == 1) %>%
### On selectionne uniquement le port de Marseille
filter(customs_region == Ville) %>%
### Les chaînes de charatères sont transformés en type facteur
mutate_if(is.character, as.factor) %>%
### Création ID product_simplification et ID transaction
mutate(id_prod_simp = as.numeric(product_simplification),
id_trans = row_number()) %>%
### Si aucun prix n'est affiché, on le complète par valeur /quantité
mutate(unit_price_metric = coalesce(unit_price_metric, value / quantities_metric)) %>%
### On enlève les transactions sans prix et les transactions avec un prix nul
mutate(unit_price_metric = na_if(unit_price_metric, 0),
quantities_metric = na_if(quantities_metric, 0)) %>%
drop_na() %>%
### On crée une dummy variable best_unit_metric qui pour chaque transaction vaut 1
### si la transacton est dans l'unité métrique la plus utilisée pour le produit
group_by(product_simplification) %>%
mutate(best_unit_metric = names(which.max(table(quantity_unit_metric)))) %>%
ungroup() %>%
as.data.frame() %>%
mutate(best_unit_metric = best_unit_metric == quantity_unit_metric )
### Correction indice Ag
if (Correction_indice_Ag) {
### Chargement de la base de données de la valeur de l'argent
Ag_value <- read.csv2("./scripts/Edouard/Silver_price/Silver_equivalent_of_the_lt_and_franc_(Hoffman).csv")
### On fusionne les deux bases de données
bdd_courante <- merge(bdd_courante, Ag_value, "year" = "year", all.x = T)
### On corrige les valeurs des prix
bdd_courante <- bdd_courante %>%
mutate(value = value * Value_of_livre) %>%
select(-c("Value_of_livre"))
}
### Calcule de la valeur totale du flux et du commerce initiale
Value_com_tot <- bdd_courante %>%
filter(best_guess_region_prodxpart == 1) %>%
filter(customs_region == Ville) %>%
filter(export_import == Exports_imports) %>%
group_by(year) %>%
summarize(Value_tot = sum(value, na.rm = T),
Flux_tot = n()) %>%
as.data.frame()
### Correction indice Ag
if (Correction_indice_Ag) {
### Chargement de la base de données de la valeur de l'argent
Ag_value <- read.csv2("./scripts/Edouard/Silver_price/Silver_equivalent_of_the_lt_and_franc_(Hoffman).csv")
### On fusionne les deux bases de données
Data <- merge(Data, Ag_value, "year" = "year", all.x = T)
### On corrige les valeurs des prix
Data <- Data %>%
mutate(unit_price_metric = unit_price_metric * Value_of_livre,
value = value * Value_of_livre) %>%
select(-c("Value_of_livre"))
}
if(Product_sector != "All") {
if (Product_sector == "Primary goods") {
Data <- Data %>%
filter(product_threesectors == "Agriculture" | product_threesectors == "Non-agricultural primary goods")
} else if (Product_sector == "Primary coloniaux") {
Data <- Data %>%
filter((product_threesectors == "Agriculture" | product_threesectors == "Non-agricultural primary goods")
& product_reexportations == "Réexportation")
} else if (Product_sector == "Primary european") {
Data <- Data %>%
filter((product_threesectors == "Agriculture" | product_threesectors == "Non-agricultural primary goods")
& product_reexportations != "Réexportation")
} else if (Product_sector == "Manufactures") {
Data <- Data %>%
filter(product_threesectors == "Manufactures")
}
}
if (Partner == "Europe_et_Mediterranee") {
Data <- Data %>%
filter(partner_grouping %in% c("Allemagne", "Angleterre", "Espagne",
"Flandre et autres états de l'Empereur",
"Hollande", "France", "Italie", "Levant et Barbarie",
"Nord", "Portugal", "Suisse"))
}
if (Partner == "Reste_du_monde") {
Data <- Data %>%
filter(partner_grouping %in% c("Afrique", "Amériques", "Asie", "Etats-Unis d'Amérique",
"Monde", "Outre-mers"))
}
### On conserve uniquement les données dans la meilleure unité
Data <- Data %>%
filter(best_unit_metric == T
& export_import == Exports_imports) %>%
select(-c("best_unit_metric", "best_guess_region_prodxpart", "product_threesectors",
"product_threesectorsM", "partner_grouping", "product_reexportations"))
return(list(Data, Value_com_tot))
}
Add_new_sector_global("Primary coloniaux")
Add_new_sector("Primary coloniaux")
Add_new_sector("Primary european")
Index_composition <- read.csv2("./scripts/Edouard/Composition_index_results.csv", row.names = NULL)
table(Index_composition$Product_sector)
Index_composition <- read.csv2("./scripts/Edouard/Composition_index_results.csv", row.names = NULL)
Index_composition <- Index_composition %>%
mutate_if(is.character, as.factor) %>%
mutate(Product_sector = relevel(Product_sector, "All"),
Exports_imports = relevel(Exports_imports, "Imports"))
Reg_trend_categ <- lm(log(Index_value) ~ year + Ville + Ville*year + Product_sector + Product_sector*year,
data = subset(Index_composition, Exports_imports == "Imports" & Product_sector %in% c("Manufactures", "Primary coloniaux", "Primary european") & Ville != "Rennes"))
summary(Reg_trend_categ)
Reg_trend_categ <- lm(log(Index_value) ~ year + Ville + Ville*year + Product_sector + Product_sector*year,
data = subset(Index_composition, Exports_imports == "Exports" & Product_sector %in% c("Manufactures", "Primary coloniaux", "Primary european") & Ville != "Rennes"))
summary(Reg_trend_categ)
Reg_trend_categ <- lm(log(Index_value) ~ year + Ville + Ville*year + Product_sector + Product_sector*year + Exports_imports,
data = subset(Index_composition, Product_sector %in% c("Manufactures", "Primary coloniaux", "Primary european") & Ville != "Rennes"))
summary(Reg_trend_categ)
Index_partner <- read.csv2("./scripts/Edouard/Partner_index_results.csv", row.names = NULL)
Index_partner <- Index_partner %>%
mutate_if(is.character, as.factor) %>%
mutate(Partner = relevel(Partner, "All"),
Exports_imports = relevel(Exports_imports, "Imports")) %>%
filter(Ville != "Rennes")
plot(Index_partner$year, Index_partner$Index_value, type = "o")
Reg_trend_categ <- lm(log(Index_value) ~ year + Ville + Ville*year + Partner + Partner*year,
data = subset(Index_partner, Exports_imports == "Exports" & Partner != "All"))
summary(Reg_trend_categ)
Reg_trend_partner_global <- lm(log(Index_value) ~ year + Partner + Partner*year ,
data = subset(Index_partner_global, Exports_imports == "Imports"))
summary(Reg_trend_partner_global)
Reg_trend_categ <- lm(log(Index_value) ~ year + Ville + Ville*year + Partner + Partner*year,
data = subset(Index_partner, Exports_imports == "Imports" & Partner != "All"))
summary(Reg_trend_categ)
