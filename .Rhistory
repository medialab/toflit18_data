trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Marseille_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 0)
### Création de la base de données des transactions considérées
Marseille_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Marseille_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 20)
### Création de la base de données des transactions considérées
Marseille_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Marseille_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
rm(list = ls())
### On fixe la ville que l'on veut étudier
ville = "La Rochelle"
### On importe la base de données courante
bdd_courante <- read.csv("./base/bdd courante.csv", encoding = "UTF-8")
Data <- bdd_courante %>%
select(c("year", "customs_region", "export_import", "partner_orthographic",
"product_simplification", "quantity_unit_metric", "quantities_metric", "unit_price_metric",
"best_guess_national_prodxpart", "best_guess_national_partner",
"best_guess_national_product", "best_guess_national_region",
"best_guess_region_prodxpart")) %>%
mutate(Date = as.Date(as.character(year), format = "%Y")) %>%
### On selectionne uniquement les produits rangés par régions
filter(best_guess_region_prodxpart == 1) %>%
### On selectionne uniquement le port de Marseille
filter(customs_region == ville) %>%
mutate_if(is.character, as.factor) %>%
### Création ID product_simplification et ID transaction
mutate(id_prod_simp = as.numeric(product_simplification),
id_trans = row_number()) %>%
### On enlève les transactions sans prix et les transactions avec un prix nul
mutate(unit_price_metric = na_if(unit_price_metric, 0)) %>%
drop_na(unit_price_metric) %>%
### On crée une dummy variable best_unit_metric qui pour chaque transaction vaut 1
### si la transacton est dans l'unité métrique la plus utilisée pour le produit
group_by(product_simplification) %>%
mutate(best_unit_metric = names(which.max(table(quantity_unit_metric)))) %>%
ungroup() %>%
as.data.frame() %>%
mutate(best_unit_metric = best_unit_metric == quantity_unit_metric ) %>%
### Création d'une variable qui récupère pour chaque produits le nombre de transactions
### dans la meilleure unité métrique
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame()
### Détéection valeurs aberrantes
outliers_trans <- c()
for (prod in levels(Data$product_simplification)) {
Data_imports = subset(Data,  product_simplification == prod
& export_import == "Imports"
& best_unit_metric == T)
Data_exports = subset(Data,  product_simplification == prod
& export_import == "Exports"
& best_unit_metric == T)
outliers_trans <- c(outliers_trans,
Data_imports$id_trans[which(Data_imports$unit_price_metric %in%
boxplot.stats(Data_imports$unit_price_metric, coef = 3)$out)])
}
Data <- Data %>%
mutate(outliers = id_trans %in% outliers_trans)
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 20)
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 0)
### Création de la base de données des transactions considérées
Marseille_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Marseille_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 0)
### Création de la base de données des transactions considérées
Marseille_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = F)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Marseille_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 0)
### Création de la base de données des transactions considérées
Marseille_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Marseille_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
rm(list = ls())
### On fixe la ville que l'on veut étudier
ville = "Bordeaux"
### On importe la base de données courante
bdd_courante <- read.csv("./base/bdd courante.csv", encoding = "UTF-8")
Data <- bdd_courante %>%
select(c("year", "customs_region", "export_import", "partner_orthographic",
"product_simplification", "quantity_unit_metric", "quantities_metric", "unit_price_metric",
"best_guess_national_prodxpart", "best_guess_national_partner",
"best_guess_national_product", "best_guess_national_region",
"best_guess_region_prodxpart")) %>%
mutate(Date = as.Date(as.character(year), format = "%Y")) %>%
### On selectionne uniquement les produits rangés par régions
filter(best_guess_region_prodxpart == 1) %>%
### On selectionne uniquement le port de Marseille
filter(customs_region == ville) %>%
mutate_if(is.character, as.factor) %>%
### Création ID product_simplification et ID transaction
mutate(id_prod_simp = as.numeric(product_simplification),
id_trans = row_number()) %>%
### On enlève les transactions sans prix et les transactions avec un prix nul
mutate(unit_price_metric = na_if(unit_price_metric, 0)) %>%
drop_na(unit_price_metric) %>%
### On crée une dummy variable best_unit_metric qui pour chaque transaction vaut 1
### si la transacton est dans l'unité métrique la plus utilisée pour le produit
group_by(product_simplification) %>%
mutate(best_unit_metric = names(which.max(table(quantity_unit_metric)))) %>%
ungroup() %>%
as.data.frame() %>%
mutate(best_unit_metric = best_unit_metric == quantity_unit_metric ) %>%
### Création d'une variable qui récupère pour chaque produits le nombre de transactions
### dans la meilleure unité métrique
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame()
### Détéection valeurs aberrantes
outliers_trans <- c()
for (prod in levels(Data$product_simplification)) {
Data_imports = subset(Data,  product_simplification == prod
& export_import == "Imports"
& best_unit_metric == T)
Data_exports = subset(Data,  product_simplification == prod
& export_import == "Exports"
& best_unit_metric == T)
outliers_trans <- c(outliers_trans,
Data_imports$id_trans[which(Data_imports$unit_price_metric %in%
boxplot.stats(Data_imports$unit_price_metric, coef = 3)$out)])
}
Data <- Data %>%
mutate(outliers = id_trans %in% outliers_trans)
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 0)
### Création de la base de données des transactions considérées
Marseille_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Création de la base de données des transactions considérées
Data_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
print(Data[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data$year, Data$unit_price_metric, main = prod)
}
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
print(Data_filter[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data_filter$year, Data_filter$unit_price_metric, main = prod)
}
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
Data_prod <- subset(Data_filter, product_simplification == prod)
print(Data_prod[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data_prod$year, Data_filter$unit_price_metric, main = prod)
}
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
Data_prod <- subset(Data_filter, product_simplification == prod)
print(Data_prod[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data_prod$year, Data_prod$unit_price_metric, main = prod)
}
levels(Data_filter$product_simplification)
dim(Data_prod$year)
dim(Data_prod)
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
Data_prod <- subset(Data_filter, product_simplification == prod)
if(dim(Data_prod$year)[1] == 0) {break}
print(Data_prod[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data_prod$year, Data_prod$unit_price_metric, main = prod)
}
dim(Data_prod$year)[1]
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
Data_prod <- subset(Data_filter, product_simplification == prod)
if (dim(Data_prod)[1] == 0) {break}
print(Data_prod[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data_prod$year, Data_prod$unit_price_metric, main = prod)
}
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
Data_prod <- subset(Data_filter, product_simplification == prod)
if (dim(Data_prod)[1] > 0) {
print(Data_prod[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data_prod$year, Data_prod$unit_price_metric, main = prod)
}
}
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 20)
### Création de la base de données des transactions considérées
Data_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
Data_prod <- subset(Data_filter, product_simplification == prod)
if (dim(Data_prod)[1] > 0) {
print(Data_prod[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data_prod$year, Data_prod$unit_price_metric, main = prod)
}
}
### Détéection valeurs aberrantes
outliers_trans <- c()
for (prod in levels(Data$product_simplification)) {
Data_imports = subset(Data,  product_simplification == prod
& export_import == "Imports"
& best_unit_metric == T)
Data_exports = subset(Data,  product_simplification == prod
& export_import == "Exports"
& best_unit_metric == T)
outliers_trans <- c(outliers_trans,
Data_imports$id_trans[which(Data_imports$unit_price_metric %in%
boxplot.stats(Data_imports$unit_price_metric, coef = 3)$out)])
}
Data <- Data %>%
mutate(outliers = id_trans %in% outliers_trans)
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 20)
### Création de la base de données des transactions considérées
Data_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
Data_prod <- subset(Data_filter, product_simplification == prod)
if (dim(Data_prod)[1] > 0) {
print(Data_prod[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data_prod$year, Data_prod$unit_price_metric, main = prod)
}
}
sum(Data$outliers)
### Détéection valeurs aberrantes
outliers_trans <- c()
for (prod in levels(Data$product_simplification)) {
Data_imports = subset(Data,  product_simplification == prod
& export_import == "Imports"
& best_unit_metric == T)
Data_exports = subset(Data,  product_simplification == prod
& export_import == "Exports"
& best_unit_metric == T)
outliers_trans <- c(outliers_trans,
Data_imports$id_trans[which(Data_imports$unit_price_metric %in%
boxplot.stats(Data_imports$unit_price_metric, coef = 1.5)$out)])
}
Data <- Data %>%
mutate(outliers = id_trans %in% outliers_trans)
sum(Data$outliers)
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Exports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 20)
### Création de la base de données des transactions considérées
Data_trans <- rtCreateTrans(trans_df = Data_filter,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
date = "Date",
periodicity = "yearly",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
### Affichage du résultat
plot(rt_index$period, rt_index$value, type = "l")
### On observe l'évolution des prix unitaires de tous les produits importés
### plus de xxxx fois sur la période
for (prod in levels(Data_filter$product_simplification)) {
Data_prod <- subset(Data_filter, product_simplification == prod)
if (dim(Data_prod)[1] > 0) {
print(Data_prod[, c("quantity_unit_metric", "unit_price_metric")])
plot(Data_prod$year, Data_prod$unit_price_metric, main = prod)
}
}
