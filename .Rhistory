Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
### A jout de l'index et des parts de flux et de valeur dans le commerce total, ainsi que la valeur des paramètres
### au dataframe
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i],
Part_flux = Index$Part_flux[i])
}
}
}
### On charge les valeurs actuelles du csv
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL)
### On ajoute le nouveau dataframe
Index_res <- rbind(Index_res, Index_pond)
### On retire les lignes si elles sont déja présentes dans le csv
### Par défaut, le nouveau résultat met à jour le précédent
Index_res <- Index_res[!duplicated(Index_res[ , 1:11], fromLast = T), ]
### On écrit le résulat dans le csv
write.csv2(Index_res,
"./scripts/Edouard/Index_results.csv",
row.names = F)
}
Update_base()
library(dplyr)
library(tidyverse)
library(stringr)
library(readr)
library(pracma)
library(openxlsx)
library(hpiR)
### A définir: emplacement du working directory
setwd("C:/Users/pignede/Documents/GitHub/toflit18_data")
### Nettoyage de l'espace de travail
rm(list = ls())
### On charge les fonctions des scripts Filtrage.R et Ventes_repetees_ponderees.R
source("./scripts/Edouard/Filtrage.R")
source("./scripts/Edouard/Ventes_repetees_ponderees.R")
Update_base <- function()
{
### Création des lignes du csv
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
### Ecriture des lignes du csv
write.csv2(Index_pond,
"./scripts/Edouard/Index_results.csv",
row.names = F)
### Ajout au csv de la baseline et de la baseline + changement d'un paramètre pour chaque paramètre
### à l'aide de la fonction Add_new_parma défini ci-dessous
Add_new_param()
Add_new_param(Outliers = F)
Add_new_param(Outliers_coef = 3.5)
Add_new_param(Trans_number = 20)
Add_new_param(Prod_problems = T)
Add_new_param(Product_select = T)
Add_new_param(Remove_double = F)
Add_new_param(Ponderation = F)
Add_new_param(Pond_log = T)
}
Add_new_param <- function(Outliers = T,
Outliers_coef = 10,
Trans_number = 0,
Prod_problems = F,
Product_select = F,
Remove_double = T,
Ponderation = T,
Pond_log = F)
{
### Création des titres des lignes
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle", "Bayonne", "Rennes")) {
for (Type in c("Imports", "Exports")) {
### Calcul de l'index pour les paramètres choisis
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
### A jout de l'index et des parts de flux et de valeur dans le commerce total, ainsi que la valeur des paramètres
### au dataframe
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i],
Part_flux = Index$Part_flux[i])
}
}
}
### On charge les valeurs actuelles du csv
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL)
### On ajoute le nouveau dataframe
Index_res <- rbind(Index_res, Index_pond)
### On retire les lignes si elles sont déja présentes dans le csv
### Par défaut, le nouveau résultat met à jour le précédent
Index_res <- Index_res[!duplicated(Index_res[ , 1:11], fromLast = T), ]
### On écrit le résulat dans le csv
write.csv2(Index_res,
"./scripts/Edouard/Index_results.csv",
row.names = F)
}
Update_base()
library(dplyr)
library(tidyverse)
library(stringr)
library(readr)
library(pracma)
library(openxlsx)
library(hpiR)
### A définir: emplacement du working directory
setwd("C:/Users/pignede/Documents/GitHub/toflit18_data")
### Nettoyage de l'espace de travail
rm(list = ls())
Calcul_correlation_matrix <- function()
{
### On charge les valeurs de Index_results.csv
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
### Création d'un workbook (objet comparable à un excel et converti en excel à la fin)
Cor_matrix_workbook <- createWorkbook()
### On récupère l'ensemble des villes du csv des indices
liste_ville <- unique(Index_res[ , 1])
for (Ville_cons in liste_ville) {
for (Type in c("Imports", "Exports")) {
### On récupère l'ensemble des configurations possibles avec les variables
Var_used <- unique(Index_res[ , 3:10])
### col_names est égal à la suite de l'ensemble des configurations possibles avec les variables
col_names <- c()
for (Row in seq(1, dim(Var_used)[1])) {
name <- c()
for (Col in 1:8) {
name <- paste(name, names(Var_used)[Col], ":", as.character(Var_used[Row, Col]), ";")
}
col_names <- c(col_names, name)
}
### Création de la matrice de corrélation les noms des lignes et des colonnes sont égales à col_names
Correlation_matrix <- matrix(nrow = dim(Var_used)[1], ncol = dim(Var_used)[1],
dimnames = list(col_names, col_names))
### Pour chaque configuration possible on calcule les corrélations 2 à 2 des indices
for (i in seq(1, dim(Var_used)[1])) {
for (j in seq(1, dim(Var_used)[1])) {
### Récupération de l'indice Configuration 1
Index1 <- Index_res %>%
filter(Ville == Ville_cons,
Exports_imports == Type,
Outliers == Var_used$Outliers[i],
Outliers_coef == Var_used$Outliers_coef[i],
Trans_number == Var_used$Trans_number[i],
Prod_problems == Var_used$Prod_problems[i],
Product_select == Var_used$Product_select[i],
Remove_double == Var_used$Remove_double[i],
Ponderation == Var_used$Ponderation[i],
Pond_log == Var_used$Pond_log[i]) %>%
select(c("year", "Index_value"))
### Récupération de l'indice configuration 2
Index2 <- Index_res %>%
filter(Ville == Ville_cons,
Exports_imports == Type,
Outliers == Var_used$Outliers[j],
Outliers_coef == Var_used$Outliers_coef[j],
Trans_number == Var_used$Trans_number[j],
Prod_problems == Var_used$Prod_problems[j],
Product_select == Var_used$Product_select[j],
Remove_double == Var_used$Remove_double[j],
Ponderation == Var_used$Ponderation[j],
Pond_log == Var_used$Pond_log[j]) %>%
select(c("year", "Index_value"))
### Calcul de la correlation
cor <- cor(Index1, Index2, use = "complete.obs")
### si les années sont bien comparables entre les indices (cor[1,1] > 0.99) alors on remplit la matrix de correlation
### sinon on met NA
if (cor[1,1] > 0.99) {
Correlation_matrix[i, j] = cor[2,2]
} else {
Correlation_matrix[i, j] = NA
}
}
}
### On crée un nouvel onglet ville type au workbook
addWorksheet(Cor_matrix_workbook, sheetName = paste(Ville_cons, Type))
### On ajoute la matrice de corrélation dans l'onglet ville type
writeData(Cor_matrix_workbook,
sheet = paste(Ville_cons, Type),
x = Correlation_matrix,
rowNames = T,
colNames = T)
}
}
### On sauvegarde le workbook dans l'excel Correlation_matrix.xlsx
saveWorkbook(Cor_matrix_workbook, "./scripts/Edouard/Correlation_matrix.xlsx",
overwrite = T)
}
Calcul_correlation_matrix()
library(dplyr)
library(tidyverse)
library(stringr)
library(readr)
library(pracma)
library(openxlsx)
library(hpiR)
Calcul_terme_echange <- function()
{
### On charge les onnées d'index
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
Index_res <- Index_res %>%
### On conserve uniquement la baseline
filter(Outliers == T & Outliers_coef == 10 & Trans_number == 0 & Prod_problems == F &
Product_select == F & Remove_double == T & Ponderation == T & Pond_log = F) %>%
### On garde seulement les colonnes d'indices permettant le calcul du terme de l'échange
select(c("Ville", "Exports_imports", "year", "Index_value"))
### On reshape le dataframe : c'est à dire que l'on crée deux colonnes Imports et Exports issues de la colonne Exports_imports
Index_res_reshape <- spread(Index_res, key = "Exports_Imports", value = "Index_value")
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Esports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value")
### On écrit le csv résultant
write.csv2(Termes_echange_res,
"./scripts/Edouard/Termes_echange_results.csv",
row.names = F)
}
Calcul_terme_echange <- function()
{
### On charge les onnées d'index
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
Index_res <- Index_res %>%
### On conserve uniquement la baseline
filter(Outliers == T & Outliers_coef == 10 & Trans_number == 0 & Prod_problems == F &
Product_select == F & Remove_double == T & Ponderation == T & Pond_log == F) %>%
### On garde seulement les colonnes d'indices permettant le calcul du terme de l'échange
select(c("Ville", "Exports_imports", "year", "Index_value"))
### On reshape le dataframe : c'est à dire que l'on crée deux colonnes Imports et Exports issues de la colonne Exports_imports
Index_res_reshape <- spread(Index_res, key = "Exports_Imports", value = "Index_value")
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Esports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value")
### On écrit le csv résultant
write.csv2(Termes_echange_res,
"./scripts/Edouard/Termes_echange_results.csv",
row.names = F)
}
Calcul_terme_echange()
Calcul_termes_echange <- function()
{
### On charge les onnées d'index
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
Index_res <- Index_res %>%
### On conserve uniquement la baseline
filter(Outliers == T & Outliers_coef == 10 & Trans_number == 0 & Prod_problems == F &
Product_select == F & Remove_double == T & Ponderation == T & Pond_log == F) %>%
### On garde seulement les colonnes d'indices permettant le calcul du terme de l'échange
select(c("Ville", "Exports_imports", "year", "Index_value"))
### On reshape le dataframe : c'est à dire que l'on crée deux colonnes Imports et Exports issues de la colonne Exports_imports
Index_res_reshape <- spread(Index_res, key = "Exports_imports", value = "Index_value")
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Esports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value")
### On écrit le csv résultant
write.csv2(Termes_echange_res,
"./scripts/Edouard/Termes_echange_results.csv",
row.names = F)
}
Calcul_termes_echange()
Calcul_termes_echange <- function()
{
### On charge les onnées d'index
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
Index_res <- Index_res %>%
### On conserve uniquement la baseline
filter(Outliers == T & Outliers_coef == 10 & Trans_number == 0 & Prod_problems == F &
Product_select == F & Remove_double == T & Ponderation == T & Pond_log == F) %>%
### On garde seulement les colonnes d'indices permettant le calcul du terme de l'échange
select(c("Ville", "Exports_imports", "year", "Index_value"))
### On reshape le dataframe : c'est à dire que l'on crée deux colonnes Imports et Exports issues de la colonne Exports_imports
Index_res_reshape <- spread(Index_res, key = "Exports_imports", value = "Index_value")
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Exports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value")
### On écrit le csv résultant
write.csv2(Termes_echange_res,
"./scripts/Edouard/Termes_echange_results.csv",
row.names = F)
}
Calcul_termes_echange()
### On charge les onnées d'index
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
Index_res <- Index_res %>%
### On conserve uniquement la baseline
filter(Outliers == T & Outliers_coef == 10 & Trans_number == 0 & Prod_problems == F &
Product_select == F & Remove_double == T & Ponderation == T & Pond_log == F) %>%
### On garde seulement les colonnes d'indices permettant le calcul du terme de l'échange
select(c("Ville", "Exports_imports", "year", "Index_value", "Part_value"))
### On reshape le dataframe : c'est à dire que l'on crée deux colonnes Imports et Exports issues de la colonne Exports_imports
Index_res_reshape <- spread(Index_res, key = "Exports_imports", value = "Index_value")
Index_res_reshape
### On charge les onnées d'index
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
Index_res <- Index_res %>%
### On conserve uniquement la baseline
filter(Outliers == T & Outliers_coef == 10 & Trans_number == 0 & Prod_problems == F &
Product_select == F & Remove_double == T & Ponderation == T & Pond_log == F) %>%
### On garde seulement les colonnes d'indices permettant le calcul du terme de l'échange
select(c("Ville", "Exports_imports", "year", "Index_value"))
### On reshape le dataframe : c'est à dire que l'on crée deux colonnes Imports et Exports issues de la colonne Exports_imports
Index_res_reshape <- spread(Index_res, key = "Exports_imports", value = "Index_value")
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Exports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value")
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Exports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value") %>%
mutate_if(as.character, as.factor)
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Exports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value") %>%
mutate_if(is.character, as.factor)
Ville= "Marseille"
Terme_echange <- Termes_echange_res %>%
filter(Ville == Ville) %>%
select(c("year", "Termes_echange_value"))
plot(Terme_echange, main = Ville)
Ville_cons = "Marseille"
Title = Ville_cons
Terme_echange <- Termes_echange_res %>%
filter(Ville == Ville_cons) %>%
select(c("year", "Termes_echange_value"))
plot(Terme_echange, main = Ville_cons)
plot(Terme_echange, main = Ville_cons, type = "o")
plot(drop_na(Terme_echange), main = Ville_cons, type = "o")
Calcul_termes_echange <- function()
{
### On charge les onnées d'index
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
Index_res <- Index_res %>%
### On conserve uniquement la baseline
filter(Outliers == T & Outliers_coef == 10 & Trans_number == 0 & Prod_problems == F &
Product_select == F & Remove_double == T & Ponderation == T & Pond_log == F) %>%
### On garde seulement les colonnes d'indices permettant le calcul du terme de l'échange
select(c("Ville", "Exports_imports", "year", "Index_value"))
### On reshape le dataframe : c'est à dire que l'on crée deux colonnes Imports et Exports issues de la colonne Exports_imports
Index_res_reshape <- spread(Index_res, key = "Exports_imports", value = "Index_value")
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Exports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value") %>%
mutate_if(is.character, as.factor)
### On écrit le csv résultant
write.csv2(Termes_echange_res,
"./scripts/Edouard/Termes_echange_results.csv",
row.names = F)
for (Ville_cons in levels(Termes_echange_res$Ville)) {
Title = Ville_cons
Terme_echange <- Termes_echange_res %>%
filter(Ville == Ville_cons) %>%
select(c("year", "Termes_echange_value"))
png(filename = paste0("./scripts/Edouard/Figure_termes_echange/", Title, ".png"),
width = 5000,
height = 2700,
res = 500)
plot(drop_na(Terme_echange), main = Ville_cons, type = "o")
### Fermeture de la fenêtre
dev.off()
}
}
Calcul_terme_echange()
Calcul_termes_echange <- function()
{
### On charge les onnées d'index
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
Index_res <- Index_res %>%
### On conserve uniquement la baseline
filter(Outliers == T & Outliers_coef == 10 & Trans_number == 0 & Prod_problems == F &
Product_select == F & Remove_double == T & Ponderation == T & Pond_log == F) %>%
### On garde seulement les colonnes d'indices permettant le calcul du terme de l'échange
select(c("Ville", "Exports_imports", "year", "Index_value"))
### On reshape le dataframe : c'est à dire que l'on crée deux colonnes Imports et Exports issues de la colonne Exports_imports
Index_res_reshape <- spread(Index_res, key = "Exports_imports", value = "Index_value")
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Exports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value") %>%
mutate_if(is.character, as.factor)
### On écrit le csv résultant
write.csv2(Termes_echange_res,
"./scripts/Edouard/Termes_echange_results.csv",
row.names = F)
for (Ville_cons in levels(Termes_echange_res$Ville)) {
Title = Ville_cons
Terme_echange <- Termes_echange_res %>%
filter(Ville == Ville_cons) %>%
select(c("year", "Termes_echange_value"))
png(filename = paste0("./scripts/Edouard/Figure_termes_echange/", Title, ".png"),
width = 5000,
height = 2700,
res = 500)
plot(drop_na(Terme_echange), main = Ville_cons, type = "o")
### Fermeture de la fenêtre
dev.off()
}
}
Calcul_terme_echange()
### A définir: emplacement du working directory
setwd("C:/Users/pignede/Documents/GitHub/toflit18_data")
### Nettoyage de l'espace de travail
rm(list = ls())
Calcul_termes_echange <- function()
{
### On charge les onnées d'index
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL, dec = ",")
Index_res <- Index_res %>%
### On conserve uniquement la baseline
filter(Outliers == T & Outliers_coef == 10 & Trans_number == 0 & Prod_problems == F &
Product_select == F & Remove_double == T & Ponderation == T & Pond_log == F) %>%
### On garde seulement les colonnes d'indices permettant le calcul du terme de l'échange
select(c("Ville", "Exports_imports", "year", "Index_value"))
### On reshape le dataframe : c'est à dire que l'on crée deux colonnes Imports et Exports issues de la colonne Exports_imports
Index_res_reshape <- spread(Index_res, key = "Exports_imports", value = "Index_value")
Termes_echange_res <- Index_res_reshape %>%
### Calcul du termes de l'échange
mutate(Termes_echange_value = Exports / Imports) %>%
### On conserve uniquement les colonnes d'intérêt
select("Ville", "year", "Termes_echange_value") %>%
mutate_if(is.character, as.factor)
### On écrit le csv résultant
write.csv2(Termes_echange_res,
"./scripts/Edouard/Termes_echange_results.csv",
row.names = F)
for (Ville_cons in levels(Termes_echange_res$Ville)) {
Title = Ville_cons
Terme_echange <- Termes_echange_res %>%
filter(Ville == Ville_cons) %>%
select(c("year", "Termes_echange_value"))
png(filename = paste0("./scripts/Edouard/Figure_termes_echange/", Title, ".png"),
width = 5000,
height = 2700,
res = 500)
plot(drop_na(Terme_echange), main = Ville_cons, type = "o")
### Fermeture de la fenêtre
dev.off()
}
}
Calcul_termes_echange()
