library(sp)
library(sf)
library(rgdal)
library(gstat)
library(automap)
library(raster)
library(stringr)
library(spatialEco)
library(exactextractr)
library(ncdf4)
library(tidyverse)
library(ncdump)
library(sf)
library(lattice)
library(RColorBrewer)
library(parallel)
library(chirps)
library("ggplot2")
theme_set(theme_bw())
library("sf")
library("rnaturalearth")
library("rnaturalearthdata")
library(rdhs)
### Chargement de la carte du Snégal
Senegal <- ne_states(country = "Senegal", returnclass = "sp")
install.packages("rnaturalearthhires", repos = "http://packages.ropensci.org", type = "source")
library(sp)
library(sf)
library(rgdal)
library(gstat)
library(automap)
library(raster)
library(stringr)
library(spatialEco)
library(exactextractr)
library(ncdf4)
library(tidyverse)
library(ncdump)
library(sf)
library(lattice)
library(RColorBrewer)
library(parallel)
library(chirps)
library("ggplot2")
theme_set(theme_bw())
library("sf")
library("rnaturalearth")
library("rnaturalearthdata")
library("rnaturalearthhires")
library(rdhs)
rm(list = ls())
### On se connecte à ma session DHS
set_rdhs_config(email = "edouard.pignede@ird.fr",
project = "Senegal vulnerability to climate change")
### On selectionne le DHS chargé que l'on veut télécharger
### SN => Sénégal ; FL => Flat file :plus rapide ;HR => Household Recode ; KR => children's recode
datasets_HR <- dhs_datasets(countryIds = "SN",
surveyYear = "2019",
fileFormat = "FL",
fileType = "HR" )
datasets_KR <- dhs_datasets(countryIds = "SN",
surveyYear = "2019",
fileFormat = "FL",
fileType = "KR" )
datasets_IR <- dhs_datasets(countryIds = "SN",
surveyYear = "2019",
fileFormat = "FL",
fileType = "IR" )
### On le télécharge
downloads_HR <- get_datasets(datasets_HR$FileName)
downloads_KR <- get_datasets(datasets_KR$FileName)
downloads_IR <- get_datasets(datasets_IR$FileName)
### On le charge sur R
data_hous <- readRDS(downloads_HR$SNHR8AFL)
data_child <- readRDS(downloads_KR$SNKR8AFL)
data_women <- readRDS(downloads_IR$SNIR8AFL)
data_women$v106
library(dplyr)
library(plyr)
library(tidyverse)
library(stringr)
library(readr)
library(pracma)
library(IndexNumR)
library(hpiR)
library(dplyr)
library(tidyverse)
library(stringr)
library(readr)
library(pracma)
library(IndexNumR)
library(hpiR)
### A définir
setwd("C:/Users/pignede/Documents/GitHub/toflit18_data")
rm(list = ls())
### On fixe la ville que l'on veut étudier
ville = "Nantes"
### On importe la base de données courante
bdd_courante <- read.csv("./base/bdd courante.csv", encoding = "UTF-8")
Data <- bdd_courante %>%
select(c("year", "customs_region", "export_import", "partner_orthographic",
"product_simplification", "quantity_unit_metric", "quantities_metric", "unit_price_metric",
"best_guess_national_prodxpart", "best_guess_national_partner",
"best_guess_national_product", "best_guess_national_region",
"best_guess_region_prodxpart")) %>%
mutate(Date = as.Date(as.character(year), format = "%Y")) %>%
### On selectionne uniquement les produits rangés par régions
filter(best_guess_region_prodxpart == 1) %>%
### On selectionne uniquement le port de Marseille
filter(customs_region == ville) %>%
mutate_if(is.character, as.factor) %>%
### Création ID product_simplification et ID transaction
mutate(id_prod_simp = as.numeric(product_simplification),
id_trans = row_number()) %>%
### On enlève les transactions sans prix et les transactions avec un prix nul
mutate(unit_price_metric = na_if(unit_price_metric, 0)) %>%
drop_na(unit_price_metric) %>%
### On crée une dummy variable best_unit_metric qui pour chaque transaction vaut 1
### si la transacton est dans l'unité métrique la plus utilisée pour le produit
group_by(product_simplification) %>%
mutate(best_unit_metric = names(which.max(table(quantity_unit_metric)))) %>%
ungroup() %>%
as.data.frame() %>%
mutate(best_unit_metric = best_unit_metric == quantity_unit_metric ) %>%
### Création d'une variable qui récupère pour chaque produits le nombre de transactions
### dans la meilleure unité métrique
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame()
### Détéection valeurs aberrantes
outliers_trans <- c()
for (prod in levels(Data$product_simplification)) {
Data_imports = subset(Data,  product_simplification == prod
& export_import == "Imports"
& best_unit_metric == T)
Data_exports = subset(Data,  product_simplification == prod
& export_import == "Exports"
& best_unit_metric == T)
outliers_trans <- c(outliers_trans,
Data_imports$id_trans[which(Data_imports$unit_price_metric %in%
boxplot.stats(Data_imports$unit_price_metric, coef = 1.5)$out)])
outliers_trans <- c(outliers_trans,
Data_exports$id_trans[which(Data_exports$unit_price_metric %in%
boxplot.stats(Data_exports$unit_price_metric, coef = 1.5)$out)])
}
Data <- Data %>%
mutate(outliers = id_trans %in% outliers_trans)
Data_filter <- Data %>%
filter(best_unit_metric == T
& export_import == "Imports"
& outliers == F) %>%
### On compte le nombre de transations sur la base de données filtrées
group_by(product_simplification) %>%
mutate(trans_number = sum(best_unit_metric)) %>%
ungroup() %>%
as.data.frame() %>%
### On filtre le nombre de transactions utilisées dans la méthode
filter(trans_number > 15)
### ON selectionne les produits pour lesquels il existe une différence trop importante de prix :
### multiplication des prix par 10 entre le plus petit et le plus grand quartile
prod_problems <- c()
for (prod in levels(Data$product_simplification)) {
Data_prod <- subset(Data_filter, product_simplification == prod)
if (dim(Data_prod)[1] > 0) {
if(quantile(Data_prod$unit_price_metric, probs = 3/4)/quantile(Data_prod$unit_price_metric, probs = 1/4) > 10) {
prod_problems <- c(prod_problems, prod)
}
}
}
Data_filter <- Data_filter %>%
filter(!product_simplification %in% prod_problems)
### Creation des colonnes de colonnes
Data_period <- dateToPeriod(trans_df = Data_filter,
date = 'Date',
periodicity = 'yearly')
### Création de la base de données des transactions considérées
Data_trans_hed <- hedCreateTrans(trans_df = Data_period,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
min_period_dist = 0,
seq_only = T)
### Application du modèle
hed_model <- hpiModel(model_type = "hed",
hpi_df = Data_trans_hed,
estimator = "base",
dep_var = 'price',
ind_var = c('tot_sf', 'beds', 'baths'),
log_dep = T)
### Application du modèle
hed_model <- hpiModel(model_type = "hed",
hpi_df = Data_trans_hed,
estimator = "base",
dep_var = 'unit_price_metric',
ind_var = NULL,
log_dep = T)
### Application du modèle
hed_model <- hpiModel(model_type = "hed",
hpi_df = Data_trans_hed,
estimator = "base",
dep_var = 'unit_price_metric',
ind_var = c("product_simplification"),
log_dep = T)
### Application du modèle
hed_model <- hpiModel(model_type = "hed",
hpi_df = Data_trans_hed,
estimator = "base",
dep_var = 'price_unit_metric',
ind_var = c("product_simplification"),
log_dep = T)
### Application du modèle
hed_model <- hpiModel(model_type = "hed",
hpi_df = Data_trans_hed,
estimator = "base",
dep_var = 'price',
ind_var = c("product_simplification"),
log_dep = T)
### Calacul de l'indice
hed_index <- modelToIndex(hed_model)
hed_index$numeric <- hed_index$period
### Smooth index
smooth_index <- smoothIndex(hed_index,
order = 5,
in_place = T)
### Affichage du résultat
### Indice brut
plot(hed_index)
### Smooth index
plot(smooth_index, smooth = T)
rt_series <- calcSeriesAccuracy(series_obj = rt_series,
test_method = 'forecast',
test_type = 'rt',
smooth = TRUE,
in_place = TRUE)
rt_series <- calcSeriesAccuracy(series_obj = rt_index,
test_method = 'forecast',
test_type = 'rt',
smooth = TRUE,
in_place = TRUE)
### Création de la base de données des transactions considérées
Data_trans <- rtCreateTrans(trans_df = Data_period,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
min_period_dist = 0,
seq_only = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
rt_index$numeric <- rt_index$period
### Smooth index
smooth_index <- smoothIndex(rt_index,
order = 5,
in_place = T)
### Affichage du résultat
### Indice brut
plot(rt_index)
### Smooth index
plot(smooth_index, smooth = T)
### Evaluation de l'indice
rt_index <- rtIndex(trans_df = Data_trans,
estimator = 'robust',
log_dep = TRUE,
trim_model = FALSE,
smooth = TRUE,
smooth_order = 5)
rt_accuracy <- calcAccuracy(hpi_obj = rt_index,
test_type = 'rt',
test_method = 'insample')
plot(rt_accuracy)
rt_series <- calcSeriesAccuracy(series_obj = rt_index,
test_method = 'forecast',
test_type = 'rt',
smooth = TRUE,
in_place = TRUE)
rt_series <- createSeries(hpi_obj = rt_index,
train_period = 24,
max_period = 30)
rt_series <- calcSeriesAccuracy(series_obj = rt_series,
test_method = 'forecast',
test_type = 'rt',
smooth = TRUE,
in_place = TRUE)
plot(rt_series)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "robust",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
rt_index$numeric <- rt_index$period
### Smooth index
smooth_index <- smoothIndex(rt_index,
order = 5,
in_place = T)
### Affichage du résultat
### Indice brut
plot(rt_index)
### Smooth index
plot(smooth_index, smooth = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "base",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
rt_index$numeric <- rt_index$period
### Smooth index
smooth_index <- smoothIndex(rt_index,
order = 5,
in_place = T)
### Affichage du résultat
### Indice brut
plot(rt_index)
### Smooth index
plot(smooth_index, smooth = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "weighted",
log_dep = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
rt_index$numeric <- rt_index$period
### Smooth index
smooth_index <- smoothIndex(rt_index,
order = 5,
in_place = T)
### Affichage du résultat
### Indice brut
plot(rt_index)
### Smooth index
plot(smooth_index, smooth = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "weighted",
log_dep = F)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
rt_index$numeric <- rt_index$period
### Smooth index
smooth_index <- smoothIndex(rt_index,
order = 5,
in_place = T)
### Affichage du résultat
### Indice brut
plot(rt_index)
### Smooth index
plot(smooth_index, smooth = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "weighted",
log_dep = T,
trim_model = F)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
rt_index$numeric <- rt_index$period
### Smooth index
smooth_index <- smoothIndex(rt_index,
order = 5,
in_place = T)
### Affichage du résultat
### Indice brut
plot(rt_index)
### Smooth index
plot(smooth_index, smooth = T)
### Application du modèle
rt_model <- hpiModel(model_type = "rt",
hpi_df = Data_trans,
estimator = "weighted",
log_dep = T,
trim_model = T)
### Calacul de l'indice
rt_index <- modelToIndex(rt_model)
rt_index$numeric <- rt_index$period
### Smooth index
smooth_index <- smoothIndex(rt_index,
order = 5,
in_place = T)
### Affichage du résultat
### Indice brut
plot(rt_index)
### Smooth index
plot(smooth_index, smooth = T)
#install.packages("devtools")
devtools::install_github("andykrause/hpiR")
