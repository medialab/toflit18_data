Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index = Index$Index[i],
Part_value = Index$Part_value[i])
}
}
}
Data_filtrage("Marseille")
Data = Data_filtrage("Marseille")
Index = Calcul_index(Data)
Index2 <- merge(Index, Data[ , c("year", "Part_value")], "year" = "year", all.x = T,
all.y = F)
Index2
Index
Data_part <- Data %>%
group_by(year) %>%
summarise(Part_value == mean(Part_value)) %>%
as.data_frame()
as.data.frame()
Data_part <- Data %>%
group_by(year) %>%
summarise(Part_value == mean(Part_value)) %>%
as.data.frame()
Data_part
Data_part <- Data %>%
group_by(year) %>%
summarise(Part_value = mean(Part_value)) %>%
as.data.frame()
Data_part
rt_index <- merge(Index, Data_part[ , c("year", "Part_value")], "year" = "year", all.x = T,
all.y = F)
rt_index
rm(list = ls())
### On charge la fonction de filtrage
source("./scripts/Edouard/Filtrage.R")
source("./scripts/Edouard/Ventes_repetees_ponderees.R")
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index" = numeric(),
"Part_value" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle")) {
for (Type in c("Imports", "Exports")) {
Outliers = T
Outliers_coef = 3.5
Trans_number = 0
Prod_problems = T
Product_select = F
Remove_double = T
Ponderation = T
Pond_log = F
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index = Index$Index[i],
Part_value = Index$Part_value[i])
}
}
}
Index
Index$Part_value
Index$Part_value[i]
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index = Index$Index[i],
Part_value = Index$Part_value[i])
rm(list = ls())
### On charge la fonction de filtrage
source("./scripts/Edouard/Filtrage.R")
source("./scripts/Edouard/Ventes_repetees_ponderees.R")
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index" = numeric(),
"Part_value" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle")) {
for (Type in c("Imports", "Exports")) {
Outliers = T
Outliers_coef = 3.5
Trans_number = 0
Prod_problems = T
Product_select = F
Remove_double = T
Ponderation = T
Pond_log = F
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i])
}
}
}
rm(list = ls())
### On charge la fonction de filtrage
source("./scripts/Edouard/Filtrage.R")
source("./scripts/Edouard/Ventes_repetees_ponderees.R")
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle")) {
for (Type in c("Imports", "Exports")) {
Outliers = T
Outliers_coef = 3.5
Trans_number = 0
Prod_problems = T
Product_select = F
Remove_double = T
Ponderation = T
Pond_log = F
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i])
}
}
}
Index_pond
write.csv(Index_pond,
"./scripts/Edouard/Index_results")
write.csv(Index_pond,
"./scripts/Edouard/Index_results.csv")
Index_res <- read.csv("./scripts/Edouard/Index_results.csv")
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = NULL)
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = F)
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = "")
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_res <- rbind(Index_res, Index_pond)
Index_res <- unique(Index_res)
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_res <- rbind(Index_res, Index_pond)
Index_res <- Index_res[!duplicated(Index_res), ]
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_res <- rbind(Index_res, Index_pond)
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_res <- rbind(Index_res, Index_pond)
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_res <- rbind(Index_res, Index_pond)
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_res <- rbind(Index_res, Index_pond)
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_res <- rbind(Index_res, Index_pond)
Index_res
Index_res <- Index_res[!duplicated(Index_res), ]
Index_res
options(max.print == 5
000)
options("max.print" == 5
000)
options("max.print" = 5
000)
options(max.print = 5000)
Index_res
options(max.print = 20000)
Index_res
Index_res <- Index_res[!duplicated(Index_res), ]
Index_res
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_res <- rbind(Index_res, Index_pond)
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle")) {
for (Type in c("Imports", "Exports")) {
Outliers = T
Outliers_coef = 3.5
Trans_number = 0
Prod_problems = T
Product_select = F
Remove_double = T
Ponderation = T
Pond_log = F
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i])
}
}
}
Index_pond$Trans_number
sum(Index_pond$Trans_number)
type(Index_pond$Trans_number)
Index_pond == Index_res
Index_pond$Index_value
Index_res$Index_value
Index_pond$Index_value == Index_res$Index_value
Index_res <- rbind(Index_res, Index_pond)
Index_res <- uIndex_res[!duplicated(Index_res[ , 1:11]), ]
Index_res <- Index_res[!duplicated(Index_res[ , 1:11]), ]
write.csv(Index_res,
"./scripts/Edouard/Index_results.csv")
rm(list = ls())
### On charge la fonction de filtrage
source("./scripts/Edouard/Filtrage.R")
source("./scripts/Edouard/Ventes_repetees_ponderees.R")
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle")) {
for (Type in c("Imports", "Exports")) {
Outliers = T
Outliers_coef = 10
Trans_number = 0
Prod_problems = T
Product_select = F
Remove_double = T
Ponderation = T
Pond_log = F
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i])
}
}
}
rm(list = ls())
### On charge la fonction de filtrage
source("./scripts/Edouard/Filtrage.R")
source("./scripts/Edouard/Ventes_repetees_ponderees.R")
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle")) {
for (Type in c("Imports", "Exports")) {
Outliers = T
Outliers_coef = 10
Trans_number = 0
Prod_problems = T
Product_select = F
Remove_double = T
Ponderation = T
Pond_log = F
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i])
}
}
}
### On charge les valeurs actuelles du csv
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
### On ajoute le nouveau calcul
Index_res <- rbind(Index_res, Index_pond)
### On retire les lignes si elles sont déja présentes dans le csv
Index_res <- Index_res[!duplicated(Index_res[ , 1:11]), ]
### On écrit le résulat dans le csv
write.csv(Index_res,
"./scripts/Edouard/Index_results.csv")
rm(list = ls())
### On charge la fonction de filtrage
source("./scripts/Edouard/Filtrage.R")
source("./scripts/Edouard/Ventes_repetees_ponderees.R")
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle")) {
for (Type in c("Imports", "Exports")) {
Outliers = T
Outliers_coef = 10
Trans_number = 0
Prod_problems = T
Product_select = F
Remove_double = T
Ponderation = T
Pond_log = F
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i])
}
}
}
### On charge les valeurs actuelles du csv
Index_res <- read.csv("./scripts/Edouard/Index_results.csv", row.names = 1)
### On ajoute le nouveau calcul
Index_res <- rbind(Index_res, Index_pond)
[!duplicated(Index_res[ , 1:11])
!duplicated(Index_res[ , 1:11])
duplicated(Index_res[ , 1:11])
!duplicated(Index_res[ , 1:11], fromLast = T)
### On retire les lignes si elles sont déja présentes dans le csv
Index_res <- Index_res[!duplicated(Index_res[ , 1:11], fromLast = T), ]
### On écrit le résulat dans le csv
write.csv(Index_res,
"./scripts/Edouard/Index_results.csv")
### On écrit le résulat dans le csv
write.csv(Index_res,
"./scripts/Edouard/Index_results.csv")
