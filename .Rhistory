Index = remove_missing(Index)
Title = paste0("Ville=", Ville, ";",
"Exports_imports=", Exports_imports, ";",
"Outliers=", as.character(Outliers),  ";",
"Outliers_coef=", as.character(Outliers_coef), ";",
"Trans_number=", as.character(Trans_number), ";",
"Prod_problems=", as.character(Prod_problems), ";",
"Product_select=", as.character(Product_select), ";",
"Remove_double=", as.character(Remove_double), ";",
"Ponderation=", as.character(Ponderation), ";",
"Pond_log=", as.character(Pond_log))
png(filename = paste0("./scripts/Edouard/Figure_index/", Title, ".png"),
width = 6000,
height = 3600,
res = 500)
### on plot l'indice
plot(Index, type = "o", main = Title)
dev.off()
}
Filter_calcul_index("Marseille")
### Cette fonction prend en entrée l'Index obtenue avec la fonctin Calcul_index et renvoie
### le graphe associé
Plot_index <- function(Index,
Ville,  ### Choix du port d'étude
Exports_imports = "Imports", ### On conserve les Importations ou les Exportations
Outliers = T, ### Retire-t-on les outliers ?
Outliers_coef = 3.5, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = 0, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = T, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = F, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = T, ### Retire-t-on les doublons
Ponderation = T, ### Calcul de l'indice avec ponderation ?
Pond_log = T)
{
### ON retire les valeurs manquantes
Index = remove_missing(Index)
Title = paste0("Ville=", Ville, ";",
"Exports_imports=", Exports_imports, ";",
"Outliers=", as.character(Outliers),  ";",
"Outliers_coef=", as.character(Outliers_coef), ";",
"Trans_number=", as.character(Trans_number), ";",
"Prod_problems=", as.character(Prod_problems), ";",
"Product_select=", as.character(Product_select), ";",
"Remove_double=", as.character(Remove_double), ";",
"Ponderation=", as.character(Ponderation), ";",
"Pond_log=", as.character(Pond_log))
png(filename = paste0("./scripts/Edouard/Figure_index/", Title, ".png"),
width = 5000,
height = 2500,
res = 500)
### on plot l'indice
plot(Index, type = "o", main = paste0(strwrap(Title, width = 50), collapse = "\n"))
dev.off()
}
Filter_calcul_index("Marseille")
### Cette fonction prend en entrée l'Index obtenue avec la fonctin Calcul_index et renvoie
### le graphe associé
Plot_index <- function(Index,
Ville,  ### Choix du port d'étude
Exports_imports = "Imports", ### On conserve les Importations ou les Exportations
Outliers = T, ### Retire-t-on les outliers ?
Outliers_coef = 3.5, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = 0, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = T, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = F, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = T, ### Retire-t-on les doublons
Ponderation = T, ### Calcul de l'indice avec ponderation ?
Pond_log = T)
{
### ON retire les valeurs manquantes
Index = remove_missing(Index)
Title = paste0("Ville=", Ville, ";",
"Exports_imports=", Exports_imports, ";",
"Outliers=", as.character(Outliers),  ";",
"Outliers_coef=", as.character(Outliers_coef), ";",
"Trans_number=", as.character(Trans_number), ";",
"Prod_problems=", as.character(Prod_problems), ";",
"Product_select=", as.character(Product_select), ";",
"Remove_double=", as.character(Remove_double), ";",
"Ponderation=", as.character(Ponderation), ";",
"Pond_log=", as.character(Pond_log))
png(filename = paste0("./scripts/Edouard/Figure_index/", Title, ".png"),
width = 5000,
height = 2500,
res = 500)
### on plot l'indice
plot(Index, type = "o", main = paste(strwrap(Title, width = 50), sep = "\n"))
dev.off()
}
Filter_calcul_index("Marseille")
Title = "Ville=Marseille;Exports_imports=Imports;Outliers=TRUE;Outliers_coef=3.5;Trans_number=0;Prod_problems=TRUE;Product_select=FALSE;Remove_double=TRUE;Ponderation=TRUE;Pond_log=TRUE"
paste(strwrap(Title, width = 50), sep = "\n")
strwrap(Title, width = 50)
strwrap(Title)
strwrap(Title, prefix = ";")
strwrap(Title, simplify = F)
str_wrap(Title, width = 50)
paste(strwrap(Title, width = 50), sep = "\n")
paste(strwrap(Title, width = 20), sep = "\n")
str_split(Title, pattern = ";")
str_split(Title, pattern = ";", simplify = F)
str_split(Title, pattern = ";", simplify = T)
str_split_n(Title, pattern = ";", n = 2)
str_split(Title, pattern = ";", simplify = T, n = 2)
### Cette fonction prend en entrée l'Index obtenue avec la fonctin Calcul_index et renvoie
### le graphe associé
Plot_index <- function(Index,
Ville,  ### Choix du port d'étude
Exports_imports = "Imports", ### On conserve les Importations ou les Exportations
Outliers = T, ### Retire-t-on les outliers ?
Outliers_coef = 3.5, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = 0, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = T, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = F, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = T, ### Retire-t-on les doublons
Ponderation = T, ### Calcul de l'indice avec ponderation ?
Pond_log = T)
{
### ON retire les valeurs manquantes
Index = remove_missing(Index)
Title = paste0("Ville=", Ville, ";",
"Exports_imports=", Exports_imports, ";",
"Outliers=", as.character(Outliers),  ";",
"Outliers_coef=", as.character(Outliers_coef), ";",
"Trans_number=", as.character(Trans_number), ";",
"Prod_problems=", as.character(Prod_problems), ";",
"Product_select=", as.character(Product_select), ";",
"Remove_double=", as.character(Remove_double), ";",
"Ponderation=", as.character(Ponderation), ";",
"Pond_log=", as.character(Pond_log))
png(filename = paste0("./scripts/Edouard/Figure_index/", Title, ".png"),
width = 5000,
height = 2700,
res = 500)
### on plot l'indice
plot(Index, type = "o", main = paste(Ville, Exports_imports))
dev.off()
}
Filter_calcul_index("Marseille")
library(dplyr)
library(tidyverse)
library(stringr)
library(readr)
library(pracma)
library(openxlsx)
library(hpiR)
### A définir: emplacement du working directory
setwd("C:/Users/pignede/Documents/GitHub/toflit18_data")
### Nettoyage de l'espace de travail
rm(list = ls())
### On charge les fonctions des scripts Filtrage.R et Ventes_repetees_ponderees.R
source("./scripts/Edouard/Filtrage.R")
source("./scripts/Edouard/Ventes_repetees_ponderees.R")
Update_base <- function()
{
### Création des lignes du csv
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
### Ecriture des lignes du csv
write.csv2(Index_pond,
"./scripts/Edouard/Index_results.csv",
row.names = F)
### Ajout au csv de la baseline et de la baseline + changement d'un paramètre pour chaque paramètre
### à l'aide de la fonction Add_new_parma défini ci-dessous
Add_new_param()
Add_new_param(Outliers = F)
Add_new_param(Outliers_coef = 10)
Add_new_param(Trans_number = 20)
Add_new_param(Prod_problems = T)
Add_new_param(Product_select = T)
Add_new_param(Remove_double = F)
Add_new_param(Ponderation = F)
Add_new_param(Pond_log = T)
}
Add_new_param <- function(Outliers = T,
Outliers_coef = 3.5,
Trans_number = 0,
Prod_problems = F,
Product_select = F,
Remove_double = T,
Ponderation = T,
Pond_log = F)
{
### Création des titres des lignes
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle")) {
for (Type in c("Imports", "Exports")) {
### Calcul de l'index pour les paramètres choisis
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
### A jout de l'index et des parts de flux et de valeur dans le commerce total, ainsi que la valeur des paramètres
### au dataframe
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i],
Part_flux = Index$Part_flux[i])
}
}
}
### On charge les valeurs actuelles du csv
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL)
### On ajoute le nouveau dataframe
Index_res <- rbind(Index_res, Index_pond)
### On retire les lignes si elles sont déja présentes dans le csv
### Par défaut, le nouveau résultat met à jour le précédent
Index_res <- Index_res[!duplicated(Index_res[ , 1:11], fromLast = T), ]
### On écrit le résulat dans le csv
write.csv2(Index_res,
"./scripts/Edouard/Index_results.csv",
row.names = F)
}
Update_base()
Update_base()
Update_base()
Filter_calcul_index("Marseille")
### A définir: emplacement du working directory
setwd("C:/Users/pignede/Documents/GitHub/toflit18_data")
### Nettoyage de l'espace de travail
rm(list = ls())
### On charge la fonction du script Filtrage.R
source("./scripts/Edouard/Filtrage.R")
### Cette fonction calcule l'index des ventes répétés à partir d'un objet Data retourné
### par la fonction Data_filtrage du script filtrage
Calcul_index <- function(Data, Ponderation = T, Pond_log = F) {
### Calcul des pondérations
Product_pond <- Data %>%
group_by(id_prod_simp) %>%
summarize(Value_tot_log = log(sum(value)),
Value_tot = sum(value))
### On
Product_pond$Value_part_log <- round(10000 * Product_pond$Value_tot_log / sum(Product_pond$Value_tot_log, na.rm = T))
Product_pond$Value_part <- round(10000 * Product_pond$Value_tot / sum(Product_pond$Value_tot, na.rm = T))
### Creation de la colonne des périodes
Data_period <- dateToPeriod(trans_df = Data,
date = 'Date',
periodicity = 'yearly')
### Creation de la base de données des transactions
### Création de la base de données des transactions considérées
Data_trans <- rtCreateTrans(trans_df = Data_period,
prop_id = "id_prod_simp",
trans_id = "id_trans",
price = "unit_price_metric",
min_period_dist = 0,
seq_only = T)
### Calcul de l'indice
### price_diff et le log de la différence de prix pour chaque transationn considérée
price_diff <- log(Data_trans$price_2) - log(Data_trans$price_1)
### time_matrix est obtenue à partir de la fonction rtTimeMatrix du package hpiR. Cette fonction permet
### de renvoyer une matrice qui considèrera chaque transaction à sa place dans le calcule de l'indice
time_matrix <- rtTimeMatrix(Data_trans)
### On ajoute à la matrice des transactions, les pondérations calculées précedemment
Data_trans <- Data_trans %>%
left_join(Product_pond, by = c("prop_id" = "id_prod_simp"))
### Calcul de la régression selon que l'on est choisi de pondéré par la part dans la valeur totale
### ou par le log de la valeur totale ou pas de pondération
if (Ponderation) {
if (Pond_log) {
reg <- lm(price_diff ~ time_matrix + 0, weights = Data_trans$Value_part_log) ### + 0 permet de supprimer l'intercept
} else {
reg <- lm(price_diff ~ time_matrix + 0, weights = Data_trans$Value_part)
}
} else {
reg <- lm(price_diff ~ time_matrix + 0)
}
### Construction de l'indice
rt_pond_index <- data.frame("year" = seq(min(Data$year), min(Data$year) + length(reg$coefficients)),
"Index" = 100*exp(c(0, reg$coefficients)),
row.names = NULL)
### On retourne l'indice
return(rt_pond_index)
}
### Cette fonction prend en entrée l'Index obtenue avec la fonctin Calcul_index et renvoie
### le graphe associé
Plot_index <- function(Index,
Ville,  ### Choix du port d'étude
Exports_imports = "Imports", ### On conserve les Importations ou les Exportations
Outliers = T, ### Retire-t-on les outliers ?
Outliers_coef = 3.5, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = 0, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = T, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = F, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = T, ### Retire-t-on les doublons
Ponderation = T, ### Calcul de l'indice avec ponderation ?
Pond_log = F)
{
### ON retire les valeurs manquantes
Index = remove_missing(Index)
### Nom du fichier
Title = paste0("Ville=", Ville, ";",
"Exports_imports=", Exports_imports, ";",
"Outliers=", as.character(Outliers),  ";",
"Outliers_coef=", as.character(Outliers_coef), ";",
"Trans_number=", as.character(Trans_number), ";",
"Prod_problems=", as.character(Prod_problems), ";",
"Product_select=", as.character(Product_select), ";",
"Remove_double=", as.character(Remove_double), ";",
"Ponderation=", as.character(Ponderation), ";",
"Pond_log=", as.character(Pond_log))
### Ouverture d'une fenêtre pour l'enregistrement du graphique
png(filename = paste0("./scripts/Edouard/Figure_index/", Title, ".png"),
width = 5000,
height = 2700,
res = 500)
### Enregistrement du graphique
plot(Index, type = "o", main = paste(Ville, Exports_imports))
### Fermetuyre de la fenêtre
dev.off()
}
Filter_calcul_index <- function(Ville,  ### Choix du port d'étude
Exports_imports = "Imports", ### On conserve les Importations ou les Exportations
Outliers = T, ### Retire-t-on les outliers ?
Outliers_coef = 3.5, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = 0, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = T, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = F, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = T, ### Retire-t-on les doublons
Ponderation = T, ### Calcul de l'indice avec ponderation ?
Pond_log = F) ### Si ponderation == T, pondère-t-on par le log de la part dans la valeur totale ?
{
### Filtrage de la base de données avec la fonction du scrip Filtrage.R
Data_filter <- Data_filtrage(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Exports_imports, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### conservation des outliers
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix très importants
Product_select = Product_select, ### Selection des produits par Charles Loic
Remove_double = Remove_double) ### On retire les doublons
### Calcul de l'indice avec la fonction Calcul_index
rt_index <- Calcul_index(Data_filter, Ponderation = Ponderation, Pond_log = Pond_log)
### On plot l'index avec la fonction Plot_index
Plot_index(rt_index, Ville = Ville, Exports_imports = Exports_imports,
Outliers = Outliers, Outliers_coef = Outliers_coef,
Trans_number = Trans_number, Prod_problems = Prod_problems,
Product_select = Product_select, Remove_double = Remove_double,
Ponderation = Ponderation, Pond_log = Pond_log)
### On calcul la part pris en compte dans le flux total et dans le commerce totale du port et du type en question
Data_part <- Data_filter %>%
group_by(year) %>%
summarise(Part_value = mean(Part_value),
Part_flux = mean(Part_flux)) %>%
as.data.frame()
### On ajoute à l'indice les colonnes de Part_value et Part_flux
rt_index <- merge(rt_index, Data_part[ , c("year", "Part_value", "Part_flux")], "year" = "year", all.x = T,
all.y = F)
### On retourne l'indice obtenu
return(rt_index)
}
Filter_calcul_index("Marseille")
library(dplyr)
library(tidyverse)
library(stringr)
library(readr)
library(pracma)
library(openxlsx)
library(hpiR)
### A définir: emplacement du working directory
setwd("C:/Users/pignede/Documents/GitHub/toflit18_data")
### Nettoyage de l'espace de travail
rm(list = ls())
### On charge les fonctions des scripts Filtrage.R et Ventes_repetees_ponderees.R
source("./scripts/Edouard/Filtrage.R")
source("./scripts/Edouard/Ventes_repetees_ponderees.R")
Update_base <- function()
{
### Création des lignes du csv
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
### Ecriture des lignes du csv
write.csv2(Index_pond,
"./scripts/Edouard/Index_results.csv",
row.names = F)
### Ajout au csv de la baseline et de la baseline + changement d'un paramètre pour chaque paramètre
### à l'aide de la fonction Add_new_parma défini ci-dessous
Add_new_param()
Add_new_param(Outliers = F)
Add_new_param(Outliers_coef = 10)
Add_new_param(Trans_number = 20)
Add_new_param(Prod_problems = T)
Add_new_param(Product_select = T)
Add_new_param(Remove_double = F)
Add_new_param(Ponderation = F)
Add_new_param(Pond_log = T)
}
Add_new_param <- function(Outliers = T,
Outliers_coef = 3.5,
Trans_number = 0,
Prod_problems = F,
Product_select = F,
Remove_double = T,
Ponderation = T,
Pond_log = F)
{
### Création des titres des lignes
Index_pond <-  data.frame("Ville" = factor(),
"Exports_imports" = factor(),
"Outliers" = logical(),
"Outliers_coef" = numeric(),
"Trans_number" = integer(),
"Prod_problems" = logical(),
"Product_select" = logical(),
"Remove_double" = logical(),
"Ponderation" = logical(),
"Pond_log" = logical(),
"year" = integer(),
"Index_value" = numeric(),
"Part_value" = numeric(),
"Part_flux" = numeric())
for (Ville in c("Nantes", "Marseille", "Bordeaux", "La Rochelle")) {
for (Type in c("Imports", "Exports")) {
### Calcul de l'index pour les paramètres choisis
Index <- Filter_calcul_index(Ville = Ville,  ### Choix du port d'étude
Exports_imports = Type, ### On conserve les Importations ou les Exportations
Outliers = Outliers, ### Retire-t-on les outliers ?
Outliers_coef = Outliers_coef, ### Quel niveau d'écart inter Q garde-t-on pour le calcul des outliers ?
Trans_number = Trans_number, ### On retire les produits vendus moins de Trans_number fois
Prod_problems = Prod_problems, ### Enleve-t-on les produits avec des différences de prix trop importantes
Product_select = Product_select, ### Conserve-t-on uniquement les produits sélectionnés par Loïc
Remove_double = Remove_double, ### Retire-t-on les doublons
Ponderation = Ponderation, ### Calcul de l'indice avec ponderation ?
Pond_log = Pond_log)
### A jout de l'index et des parts de flux et de valeur dans le commerce total, ainsi que la valeur des paramètres
### au dataframe
for (i in seq(1,dim(Index)[1])) {
Index_pond <- Index_pond %>%
add_row(Ville = Ville,
Exports_imports = Type,
Outliers = Outliers,
Outliers_coef = Outliers_coef,
Trans_number = Trans_number,
Prod_problems = Prod_problems,
Product_select = Product_select,
Remove_double = Remove_double,
Ponderation = Ponderation,
Pond_log = Pond_log,
year = Index$year[i],
Index_value = Index$Index[i],
Part_value = Index$Part_value[i],
Part_flux = Index$Part_flux[i])
}
}
}
### On charge les valeurs actuelles du csv
Index_res <- read.csv2("./scripts/Edouard/Index_results.csv", row.names = NULL)
### On ajoute le nouveau dataframe
Index_res <- rbind(Index_res, Index_pond)
### On retire les lignes si elles sont déja présentes dans le csv
### Par défaut, le nouveau résultat met à jour le précédent
Index_res <- Index_res[!duplicated(Index_res[ , 1:11], fromLast = T), ]
### On écrit le résulat dans le csv
write.csv2(Index_res,
"./scripts/Edouard/Index_results.csv",
row.names = F)
}
Update_base()
